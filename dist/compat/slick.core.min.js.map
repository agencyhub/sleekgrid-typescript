{
  "version": 3,
  "sources": ["../../src/core/index.ts", "../../src/core/base.ts", "../../src/core/event.ts", "../../src/core/editlock.ts", "../../src/core/group.ts", "../../src/core/range.ts"],
  "sourcesContent": ["export * from \"./base\";\nexport * from \"./event\";\nexport * from \"./editlock\";\nexport * from \"./group\";\nexport * from \"./range\";\n", "/***\n * A base class that all special / non-data rows (like Group and GroupTotals) derive from.\n */\nexport class NonDataRow {\n    __nonDataRow: boolean = true;\n}\n\nexport const preClickClassName = \"slick-edit-preclick\";\n\n//@ts-ignore\ntypeof window !== \"undefined\" && window.Slick && (window.Slick.Map = Map);\n", "export type Handler<TArgs, TEventData extends IEventData = IEventData> = (e: TEventData, args: TArgs) => void;\n\nexport interface IEventData {\n    readonly type?: string;\n    currentTarget?: EventTarget;\n    target?: EventTarget;\n    originalEvent?: any;\n    defaultPrevented?: boolean;\n    preventDefault?(): void;\n    stopPropagation?(): void;\n    stopImmediatePropagation?(): void;\n    isDefaultPrevented?(): boolean;\n    isImmediatePropagationStopped?(): boolean;\n    isPropagationStopped?(): boolean;\n}\n\n/***\n * An event object for passing data to event handlers and letting them control propagation.\n * <p>This is pretty much identical to how W3C and jQuery implement events.</p>\n * @class EventData\n * @constructor\n */\nexport class EventData implements IEventData {\n    private _isPropagationStopped = false;\n    private _isImmediatePropagationStopped = false;\n\n    /***\n     * Stops event from propagating up the DOM tree.\n     * @method stopPropagation\n     */\n    stopPropagation() {\n        this._isPropagationStopped = true;\n    }\n\n    /***\n     * Returns whether stopPropagation was called on this event object.\n     * @method isPropagationStopped\n     * @return {Boolean}\n     */\n    isPropagationStopped(): boolean {\n        return this._isPropagationStopped;\n    }\n\n    /***\n     * Prevents the rest of the handlers from being executed.\n     * @method stopImmediatePropagation\n     */\n    stopImmediatePropagation() {\n        this._isImmediatePropagationStopped = true;\n    }\n\n    /***\n     * Returns whether stopImmediatePropagation was called on this event object.\\\n     * @method isImmediatePropagationStopped\n     * @return {Boolean}\n     */\n    isImmediatePropagationStopped(): boolean {\n        return this._isImmediatePropagationStopped;\n    }\n}\n\n/***\n * A simple publisher-subscriber implementation.\n * @class Event\n * @constructor\n */\nexport class Event<TArgs = any, TEventData extends IEventData = IEventData> {\n\n    private _handlers: Handler<TArgs, TEventData>[] = [];\n\n    /***\n     * Adds an event handler to be called when the event is fired.\n     * <p>Event handler will receive two arguments - an <code>EventData</code> and the <code>data</code>\n     * object the event was fired with.<p>\n     * @method subscribe\n     * @param fn {Function} Event handler.\n     */\n    subscribe(fn: Handler<TArgs, TEventData>) {\n        this._handlers.push(fn);\n    }\n\n    /***\n     * Removes an event handler added with <code>subscribe(fn)</code>.\n     * @method unsubscribe\n     * @param fn {Function} Event handler to be removed.\n     */\n    unsubscribe(fn: Handler<TArgs, TEventData>) {\n        for (var i = this._handlers.length - 1; i >= 0; i--) {\n            if (this._handlers[i] === fn) {\n                this._handlers.splice(i, 1);\n            }\n        }\n    }\n\n    /***\n     * Fires an event notifying all subscribers.\n     * @method notify\n     * @param args {Object} Additional data object to be passed to all handlers.\n     * @param e {EventData}\n     *      Optional.\n     *      An <code>EventData</code> object to be passed to all handlers.\n     *      For DOM events, an existing W3C/jQuery event object can be passed in.\n     * @param scope {Object}\n     *      Optional.\n     *      The scope (\"this\") within which the handler will be executed.\n     *      If not specified, the scope will be set to the <code>Event</code> instance.\n     */\n    notify(args?: any, e?: TEventData, scope?: object) {\n        e = patchEvent(e) || new EventData() as any;\n        scope = scope || this;\n\n        var returnValue;\n        for (var i = 0; i < this._handlers.length && !(e.isPropagationStopped() || e.isImmediatePropagationStopped()); i++) {\n            returnValue = this._handlers[i].call(scope, e, args);\n        }\n\n        return returnValue;\n    }\n\n    clear() {\n        this._handlers = [];\n    }\n}\n\ninterface EventHandlerEntry<TArgs = any, TEventData extends IEventData = IEventData> {\n    event: Event<TArgs, TEventData>;\n    handler: Handler<TArgs, TEventData>;\n}\n\nexport class EventHandler<TArgs = any, TEventData extends IEventData = IEventData>  {\n    private _handlers: EventHandlerEntry<TArgs, TEventData>[] = [];\n\n    subscribe(event: Event<TArgs, TEventData>, handler: Handler<TArgs, TEventData>): this {\n        this._handlers.push({\n            event: event,\n            handler: handler\n        });\n        event.subscribe(handler);\n\n        return this;\n    }\n\n    unsubscribe(event: Event<TArgs, TEventData>, handler: Handler<TArgs, TEventData>): this {\n        var i = this._handlers.length;\n        while (i--) {\n            if (this._handlers[i].event === event &&\n                this._handlers[i].handler === handler) {\n                this._handlers.splice(i, 1);\n                event.unsubscribe(handler);\n                return;\n            }\n        }\n\n        return this;\n    }\n\n    unsubscribeAll(): EventHandler<TArgs, TEventData> {\n        var i = this._handlers.length;\n        while (i--) {\n            this._handlers[i].event.unsubscribe(this._handlers[i].handler);\n        }\n        this._handlers = [];\n\n        return this;  // allow chaining\n    }\n}\n\nexport const keyCode = {\n    BACKSPACE: 8,\n    DELETE: 46,\n    DOWN: 40,\n    END: 35,\n    ENTER: 13,\n    ESCAPE: 27,\n    HOME: 36,\n    INSERT: 45,\n    LEFT: 37,\n    PAGEDOWN: 34,\n    PAGEUP: 33,\n    RIGHT: 39,\n    TAB: 9,\n    UP: 38\n}\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// patches event so that it has methods jQuery event objects provides, for backward compatibility when jQuery is not loaded\nexport function patchEvent(e: IEventData) {\n    if (e == null)\n        return e;\n\n    if (!e.isDefaultPrevented && e.preventDefault)\n        e.isDefaultPrevented = function() { return this.defaultPrevented; }\n\n    var org1: () => void, org2: () => void;\n    if (!e.isImmediatePropagationStopped && (org1 = e.stopImmediatePropagation)) {\n        e.isImmediatePropagationStopped = returnFalse;\n        e.stopImmediatePropagation = function() { this.isImmediatePropagationStopped = returnTrue; org1.call(this); }\n    }\n\n    if (!e.isPropagationStopped && (org2 = e.stopPropagation)) {\n        e.isPropagationStopped = returnFalse;\n        e.stopPropagation = function() { this.isPropagationStopped = returnTrue; org2.call(this); }\n    }\n\n    return e;\n}\n", "export interface EditController {\n    commitCurrentEdit(): boolean;\n    cancelCurrentEdit(): boolean;\n}\n\n/***\n * A locking helper to track the active edit controller and ensure that only a single controller\n * can be active at a time.  This prevents a whole class of state and validation synchronization\n * issues.  An edit controller (such as SleekGrid) can query if an active edit is in progress\n * and attempt a commit or cancel before proceeding.\n * @class EditorLock\n * @constructor\n */\nexport class EditorLock {\n    private activeEditController: EditController;\n\n    /***\n     * Returns true if a specified edit controller is active (has the edit lock).\n     * If the parameter is not specified, returns true if any edit controller is active.\n     * @method isActive\n     * @param editController {EditController}\n     * @return {Boolean}\n     */\n    isActive(editController?: EditController): boolean {\n        return (editController ? this.activeEditController === editController : this.activeEditController != null);\n    }\n\n    /***\n     * Sets the specified edit controller as the active edit controller (acquire edit lock).\n     * If another edit controller is already active, and exception will be thrown.\n     * @method activate\n     * @param editController {EditController} edit controller acquiring the lock\n     */\n    activate(editController: EditController) {\n        if (editController === this.activeEditController) { // already activated?\n            return;\n        }\n        if (this.activeEditController != null) {\n            throw \"SleekGrid.EditorLock.activate: an editController is still active, can't activate another editController\";\n        }\n        if (!editController.commitCurrentEdit) {\n            throw \"SleekGrid.EditorLock.activate: editController must implement .commitCurrentEdit()\";\n        }\n        if (!editController.cancelCurrentEdit) {\n            throw \"SleekGrid.EditorLock.activate: editController must implement .cancelCurrentEdit()\";\n        }\n        this.activeEditController = editController;\n    }\n\n    /***\n     * Unsets the specified edit controller as the active edit controller (release edit lock).\n     * If the specified edit controller is not the active one, an exception will be thrown.\n     * @method deactivate\n     * @param editController {EditController} edit controller releasing the lock\n     */\n    deactivate(editController: EditController) {\n        if (this.activeEditController !== editController) {\n            throw \"SleekGrid.EditorLock.deactivate: specified editController is not the currently active one\";\n        }\n        this.activeEditController = null;\n    }\n\n    /***\n     * Attempts to commit the current edit by calling \"commitCurrentEdit\" method on the active edit\n     * controller and returns whether the commit attempt was successful (commit may fail due to validation\n     * errors, etc.).  Edit controller's \"commitCurrentEdit\" must return true if the commit has succeeded\n     * and false otherwise.  If no edit controller is active, returns true.\n     * @method commitCurrentEdit\n     * @return {Boolean}\n     */\n    commitCurrentEdit(): boolean {\n        return (this.activeEditController ? this.activeEditController.commitCurrentEdit() : true);\n    }\n\n    /***\n     * Attempts to cancel the current edit by calling \"cancelCurrentEdit\" method on the active edit\n     * controller and returns whether the edit was successfully cancelled.  If no edit controller is\n     * active, returns true.\n     * @method cancelCurrentEdit\n     * @return {Boolean}\n     */\n    cancelCurrentEdit(): boolean {\n        return (this.activeEditController ? this.activeEditController.cancelCurrentEdit() : true);\n    }\n}\n\n/***\n * A global singleton editor lock.\n * @class GlobalEditorLock\n * @static\n * @constructor\n */\nexport const GlobalEditorLock = new EditorLock();\n", "import { NonDataRow } from \"./base\";\n\n/***\n * Information about a group of rows.\n */\nexport class Group<TEntity = any> extends NonDataRow {\n    readonly __group = true;\n\n    /**\n     * Grouping level, starting with 0.\n     * @property level\n     * @type {Number}\n     */\n    level: number = 0;\n\n    /***\n     * Number of rows in the group.\n     * @property count\n     * @type {Integer}\n     */\n    count: number = 0;\n\n    /***\n     * Grouping value.\n     * @property value\n     * @type {Object}\n     */\n    value: any;\n\n    /***\n     * Formatted display value of the group.\n     * @property title\n     * @type {String}\n     */\n    title: string;\n\n    /***\n     * Whether a group is collapsed.\n     * @property collapsed\n     * @type {Boolean}\n     */\n    collapsed: boolean = false;\n\n    /***\n     * GroupTotals, if any.\n     * @property totals\n     * @type {GroupTotals}\n     */\n    totals: GroupTotals<TEntity>;\n\n    /**\n     * Rows that are part of the group.\n     * @property rows\n     * @type {Array}\n     */\n    rows: TEntity[] = [];\n\n    /**\n     * Sub-groups that are part of the group.\n     * @property groups\n     * @type {Array}\n     */\n    groups: Group<TEntity>[];\n\n    /**\n     * A unique key used to identify the group.  This key can be used in calls to DataView\n     * collapseGroup() or expandGroup().\n     * @property groupingKey\n     * @type {Object}\n     */\n    groupingKey: string;\n}\n\n/***\n * Information about group totals.\n * An instance of GroupTotals will be created for each totals row and passed to the aggregators\n * so that they can store arbitrary data in it.  That data can later be accessed by group totals\n * formatters during the display.\n * @class GroupTotals\n * @extends Sleek.NonDataRow\n * @constructor\n */\n export class GroupTotals<TEntity = any> extends NonDataRow {\n\n    readonly __groupTotals = true;\n\n    /***\n     * Parent Group.\n     * @param group\n     * @type {Group}\n     */\n    group: Group<TEntity>;\n\n    /***\n     * Whether the totals have been fully initialized / calculated.\n     * Will be set to false for lazy-calculated group totals.\n     * @param initialized\n     * @type {Boolean}\n     */\n    initialized: boolean = false;\n\n    /** \n     * Contains sum\n     */\n    sum?: number;\n\n    /** \n     * Contains avg\n     */\n    avg?: number;\n\n    /** \n     * Contains min\n     */\n    min?: any;\n\n    /** \n     * Contains max\n     */\n    max?: any;\n}\n", "/*\n * A structure containing a range of cells.\n * @param fromRow {Integer} Starting row.\n * @param fromCell {Integer} Starting cell.\n * @param toRow {Integer} Optional. Ending row. Defaults to <code>fromRow</code>.\n * @param toCell {Integer} Optional. Ending cell. Defaults to <code>fromCell</code>.\n */\nexport class Range {\n\n    public fromRow: number;\n    public fromCell: number;\n    public toRow: number;\n    public toCell: number;\n\n    constructor(fromRow: number, fromCell: number, toRow?: number, toCell?: number) {\n        if (toRow === undefined && toCell === undefined) {\n            toRow = fromRow;\n            toCell = fromCell;\n        }\n\n        this.fromRow = Math.min(fromRow, toRow);\n        this.fromCell = Math.min(fromCell, toCell);\n        this.toRow = Math.max(fromRow, toRow);\n        this.toCell = Math.max(fromCell, toCell);\n    }\n\n    /***\n     * Returns whether a range represents a single row.\n     */\n    isSingleRow(): boolean {\n        return this.fromRow == this.toRow;\n    }\n\n    /***\n     * Returns whether a range represents a single cell.\n     */\n    isSingleCell(): boolean {\n        return this.fromRow == this.toRow && this.fromCell == this.toCell;\n    }\n\n    /***\n     * Returns whether a range contains a given cell.\n     */\n    contains(row: number, cell: number): boolean {\n        return row >= this.fromRow && row <= this.toRow &&\n            cell >= this.fromCell && cell <= this.toCell;\n    }\n\n    /***\n     * Returns a readable representation of a range.\n     */\n    toString(): string {\n        if (this.isSingleCell()) {\n            return \"(\" + this.fromRow + \":\" + this.fromCell + \")\";\n        }\n        else {\n            return \"(\" + this.fromRow + \":\" + this.fromCell + \" - \" + this.toRow + \":\" + this.toCell + \")\";\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["core_exports", "__export", "EditorLock", "Event", "EventData", "EventHandler", "GlobalEditorLock", "Group", "GroupTotals", "NonDataRow", "Range", "keyCode", "patchEvent", "preClickClassName", "NonDataRow", "preClickClassName", "EventData", "Event", "fn", "i", "args", "scope", "patchEvent", "returnValue", "EventHandler", "event", "handler", "keyCode", "returnTrue", "returnFalse", "e", "org1", "org2", "EditorLock", "editController", "GlobalEditorLock", "Group", "NonDataRow", "GroupTotals", "Range", "fromRow", "fromCell", "toRow", "toCell", "row", "cell"]
}
